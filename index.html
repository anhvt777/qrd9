<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>PGD ƒê∆Ø·ªúNG 9 - BIDV QU·∫¢NG TR·ªä t·∫°o QR theo l√¥</title>

  <!-- Th∆∞ vi·ªán -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>

  <style>
    body { font-family: Arial, sans-serif; margin: 0; background: #f5f6fa; }
    header {
      background: #006B68;
      color: white;
      padding: 18px 12px;
      text-align: center;
      box-shadow: 0 2px 6px rgba(0,0,0,0.15);
    }
    header h1 { margin: 0; font-size: 20px; }
    header p { margin: 6px 0 0; font-size: 13px; opacity: 0.95; }

    .marquee {
      overflow: hidden; position: relative; height: 26px; margin-top: 8px;
    }
    .marquee span {
      display: inline-block; white-space: nowrap; position: absolute;
      will-change: transform; animation: marquee 30s linear infinite;
      font-size: 13px; font-weight: bold; color: #FFC62F;
    }
    @keyframes marquee { 0% { transform: translateX(100%);} 100% { transform: translateX(-100%);} }

    main { padding: 18px; max-width: 1100px; margin: 0 auto; }

    #controls { margin-bottom: 16px; display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    #upload { padding:8px; border-radius:6px; border:1px solid #ccc; background:white; min-width:220px; }
    #search { padding:8px 10px; border-radius:6px; border:1px solid #ccc; flex:1; min-width:240px; }
    #downloadAll {
      background:#FFC62F; color:#006B68; border:none; padding:8px 14px; border-radius:6px; cursor:pointer; font-weight:bold;
    }
    #downloadAll:hover { background:#e6b22b; }

    #qrs {
      display:grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap:14px;
    }
    .qr-item {
      background:white; border-radius:8px; padding:12px; text-align:center;
      box-shadow: 0 2px 6px rgba(0,0,0,0.08); border:1px solid #e6e6e6;
    }
    .qr-item p { margin:0 0 8px 0; font-size:13px; color:#333; line-height:1.25; }
    .qr-item img { display:block; margin:auto; max-width:100%; width: 220px; height:auto; border:1px solid #ddd; background:white; }
    .qr-item a { display:inline-block; margin-top:8px; text-decoration:none; color:#0070f3; font-size:13px; }

    @media (max-width:600px) {
      header h1 { font-size: 16px; }
      header p, .marquee span { font-size: 11px; }
      .qr-item img { width: 170px; }
    }
  </style>
</head>
<body>
  <header>
    <h1>PGD ƒê∆Ø·ªúNG 9 - BIDV QU·∫¢NG TR·ªä - Tool Excel ‚Üí QR Code</h1>
    <p>T·∫£i file Excel ƒë·ªÉ sinh QR (in th√¥ng tin l√™n ·∫£nh), t√¨m ki·∫øm v√† t·∫£i v·ªÅ</p>
    <div class="marquee"><span>üéâ ∆Øu ƒë√£i: T·∫∑ng qu√† & l√£i su·∫•t ∆∞u ƒë√£i ‚Äî Li√™n h·ªá Mr. M·∫°nh H√πng (0914 179 989) üéâ</span></div>
  </header>

  <main>
    <div id="controls">
      <input id="upload" type="file" accept=".xlsx,.xls" />
      <input id="search" type="text" placeholder="üîç T√¨m theo AccountName / AccountNumber / Amount / Remark..." />
      <button id="downloadAll" style="display:none;">‚¨á T·∫£i t·∫•t c·∫£ QR (ZIP)</button>
    </div>

    <div id="qrs"></div>
  </main>

  <script>
    // Gi·ªØ d·ªØ li·ªáu
    let allData = [];      // m·∫£ng c√°c item {AccountNumber,Bank,BankBin,Amount,AccountName,Remark,qrUrl,dataUrl}
    let qrList = [];       // m·∫£ng ·∫£nh ƒë√£ s·∫µn s√†ng ƒë·ªÉ zip [{filename,dataUrl}]

    // DOM
    const uploadEl = document.getElementById('upload');
    const searchEl = document.getElementById('search');
    const qrsContainer = document.getElementById('qrs');
    const downloadBtn = document.getElementById('downloadAll');

    uploadEl.addEventListener('change', handleFile, false);
    searchEl.addEventListener('input', () => filterQR(), false);
    downloadBtn.addEventListener('click', downloadAll, false);

    // ƒê·ªçc file Excel
    function handleFile(e) {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(event) {
        const data = new Uint8Array(event.target.result);
        const workbook = XLSX.read(data, {type:'array'});
        const sheet = workbook.Sheets[workbook.SheetNames[0]];
        const rows = XLSX.utils.sheet_to_json(sheet, {header:1});
        allData = [];
        qrList = [];
        qrsContainer.innerHTML = "";

        for (let i = 1; i < rows.length; i++) {
          const row = rows[i] || [];
          const AccountNumber = row[0] ? String(row[0]).trim() : "";
          const Bank = row[1] ? String(row[1]).trim() : "";
          const BankBin = row[2] ? String(row[2]).trim() : "";
          const Amount = row[3] ? String(row[3]).trim() : "";
          const AccountName = row[4] ? String(row[4]).trim() : "";
          const Remark = row[5] ? String(row[5]).trim() : "";

          if (!AccountNumber) continue;

          // QR image source (originally vietqr). We'll try to fetch this; if failed, fallback to generate local QR.
          const qrUrl = BankBin ? `https://img.vietqr.io/image/${BankBin}-${AccountNumber}-compact2.png?amount=${Amount || ''}&addInfo=${encodeURIComponent(Remark || '')}&accountName=${encodeURIComponent(AccountName || '')}` : "";

          const item = { AccountNumber, Bank, BankBin, Amount, AccountName, Remark, qrUrl, dataUrl: null };
          allData.push(item);
        }

        renderQR(allData);

        if (allData.length > 0) downloadBtn.style.display = "inline-block";
      };
      reader.readAsArrayBuffer(file);
    }

    // L·ªçc
    function filterQR() {
      const kw = (searchEl.value || "").toLowerCase();
      if (!kw) { renderQR(allData); return; }
      const filtered = allData.filter(item =>
        (item.AccountName && item.AccountName.toLowerCase().includes(kw)) ||
        (item.AccountNumber && item.AccountNumber.toLowerCase().includes(kw)) ||
        (item.Amount && item.Amount.toLowerCase().includes(kw)) ||
        (item.Remark && item.Remark.toLowerCase().includes(kw))
      );
      renderQR(filtered);
    }

    // Hi·ªÉn th·ªã list (t·∫°o placeholder, t·∫°o ·∫£nh b·∫•t ƒë·ªìng b·ªô)
    function renderQR(list) {
      qrsContainer.innerHTML = "";
      qrList = []; // reset; will be appended as images ready

      list.forEach((item, idx) => {
        const div = document.createElement('div');
        div.className = "qr-item";
        const infoHtml = `<p><b>${escapeHtml(item.AccountName || '')}</b><br>
          ${escapeHtml(item.AccountNumber || '')} (${escapeHtml(item.Bank || '')})<br>
          S·ªë ti·ªÅn: ${escapeHtml(item.Amount || '')}<br>${escapeHtml(item.Remark || '')}</p>`;

        const imgEl = document.createElement('img');
        imgEl.alt = "ƒêang t·∫°o QR...";

        const linkEl = document.createElement('a');
        linkEl.textContent = "‚¨á L∆∞u ·∫£nh";
        linkEl.href = "#";
        linkEl.setAttribute('download', `qr_${item.AccountNumber || idx}.png`);

        div.innerHTML = infoHtml;
        div.appendChild(imgEl);
        div.appendChild(linkEl);
        qrsContainer.appendChild(div);

        // T·∫°o ·∫£nh (n·∫øu ƒë√£ t·ªìn t·∫°i cache dataUrl th√¨ d√πng lu√¥n)
        createAndCacheImage(item).then(dataUrl => {
          imgEl.src = dataUrl;
          linkEl.href = dataUrl;
          // th√™m v√†o danh s√°ch zip (n·∫øu ch∆∞a c√≥)
          const existing = qrList.find(q => q.filename === `qr_${item.AccountNumber || idx}.png`);
          if (!existing) qrList.push({ filename: `qr_${item.AccountNumber || idx}.png`, dataUrl });
        }).catch(err => {
          console.error("T·∫°o ·∫£nh th·∫•t b·∫°i:", err);
          imgEl.alt = "T·∫°o QR l·ªói";
        });
      });
    }

    // T·∫°o + cache ·∫£nh (dataUrl) cho item
    async function createAndCacheImage(item) {
      if (item.dataUrl) return item.dataUrl;
      // L·∫•y canvas QR (t·ª´ remote image n·∫øu c√≥ CORS ok, n·∫øu kh√¥ng fallback t·∫°o QR)
      const qrCanvas = await getQRCodeCanvas(item);
      // Gh√©p ch·ªØ l√™n canvas m·ªõi v√† tr·∫£ v·ªÅ dataURL
      const finalDataUrl = drawTextToCanvas(qrCanvas, item);
      item.dataUrl = finalDataUrl;
      return finalDataUrl;
    }

    // Th·ª≠ t·∫£i remote image (fetch->blob->objectURL->Image) ‚Äî n·∫øu CORS ch·∫∑n s·∫Ω throw
    async function tryLoadRemoteImage(url) {
      if (!url) throw new Error("No remote URL");
      // Th·ª≠ fetch blob (works if server cho ph√©p CORS)
      const resp = await fetch(url, { mode: 'cors' });
      if (!resp.ok) throw new Error('Fetch failed');
      const blob = await resp.blob();
      return await createImageFromBlob(blob);
    }

    function createImageFromBlob(blob) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => {
          URL.revokeObjectURL(img.src);
          resolve(img);
        };
        img.onerror = (e) => reject(e);
        img.src = URL.createObjectURL(blob);
      });
    }

    // N·∫øu remote image kh√¥ng load ƒë∆∞·ª£c th√¨ fallback t·∫°o QR b·∫±ng qrcodejs
    async function getQRCodeCanvas(item) {
      const QR_SIZE = 300; // k√≠ch th∆∞·ªõc QR vu√¥ng
      // 1) c·ªë g·∫Øng load remote image (vietqr)
      try {
        if (item.qrUrl) {
          const remoteImg = await tryLoadRemoteImage(item.qrUrl);
          // chuy·ªÉn remoteImg -> canvas
          const c = document.createElement('canvas');
          c.width = QR_SIZE; c.height = QR_SIZE;
          const ctx = c.getContext('2d');
          ctx.fillStyle = '#fff';
          ctx.fillRect(0,0,c.width,c.height);
          // v·∫Ω ·∫£nh remote v√†o k√≠ch th∆∞·ªõc c·∫ßn
          ctx.drawImage(remoteImg, 0, 0, c.width, c.height);
          return c;
        } else {
          throw new Error("No remote url");
        }
      } catch (err) {
        // fallback: t·∫°o QR local b·∫±ng qrcodejs (n·ªôi dung l√† m·ªôt payload ƒë∆°n gi·∫£n ch·ª©a th√¥ng tin)
        const fallbackPayload = buildFallbackPayload(item);
        const c = await generateQRCodeCanvas(fallbackPayload, QR_SIZE);
        return c;
      }
    }

    // Sinh payload fallback (L∆ØU √ù: ƒë√¢y l√† payload text ƒë·ªÉ QR local ho·∫°t ƒë·ªông, kh√¥ng ƒë·∫£m b·∫£o ƒë√∫ng format thanh to√°n)
    function buildFallbackPayload(item) {
      // T·∫°o chu·ªói d·ªÖ hi·ªÉu ƒë·ªÉ qu√©t ra th√¥ng tin (ho·∫∑c b·∫°n c√≥ th·ªÉ ƒë·ªïi format)
      return `BIDV|BIN:${item.BankBin || ''}|ACC:${item.AccountNumber || ''}|NAME:${item.AccountName || ''}|AMT:${item.Amount || ''}|NOTE:${item.Remark || ''}`;
    }

    // Sinh canvas QR d√πng qrcodejs
    function generateQRCodeCanvas(text, size=300) {
      return new Promise((resolve) => {
        // t·∫°o th·∫ª t·∫°m ƒë·ªÉ qrcodejs render
        const temp = document.createElement('div');
        // ƒë·∫£m b·∫£o kh√¥ng hi·ªÉn th·ªã
        temp.style.position = 'fixed';
        temp.style.left = '-9999px';
        document.body.appendChild(temp);

        // t·∫°o QR
        const qrObj = new QRCode(temp, {
          text: text || '',
          width: size,
          height: size,
          correctLevel: QRCode.CorrectLevel ? QRCode.CorrectLevel.H : undefined
        });

        // qrcodejs render b·∫±ng <img> ho·∫∑c <canvas> b√™n trong temp. Ch·ªù ch√∫t r·ªìi convert
        setTimeout(() => {
          // try image first
          const img = temp.querySelector('img');
          if (img && img.src) {
            const canvas = document.createElement('canvas');
            canvas.width = size; canvas.height = size;
            const ctx = canvas.getContext('2d');
            const tmp = new Image();
            tmp.onload = () => {
              ctx.fillStyle = '#fff';
              ctx.fillRect(0,0,canvas.width,canvas.height);
              ctx.drawImage(tmp, 0, 0, canvas.width, canvas.height);
              document.body.removeChild(temp);
              resolve(canvas);
            };
            tmp.onerror = () => {
              // fallback: if img can't load, try to use the inner canvas
              const innerCanvas = temp.querySelector('canvas');
              if (innerCanvas) {
                const clone = document.createElement('canvas');
                clone.width = innerCanvas.width; clone.height = innerCanvas.height;
                clone.getContext('2d').drawImage(innerCanvas, 0, 0);
                document.body.removeChild(temp);
                resolve(clone);
              } else {
                document.body.removeChild(temp);
                resolve(null);
              }
            };
            tmp.src = img.src;
          } else {
            // maybe it rendered as canvas already
            const innerCanvas = temp.querySelector('canvas');
            if (innerCanvas) {
              const clone = document.createElement('canvas');
              clone.width = innerCanvas.width; clone.height = innerCanvas.height;
              clone.getContext('2d').drawImage(innerCanvas, 0, 0);
              document.body.removeChild(temp);
              resolve(clone);
            } else {
              document.body.removeChild(temp);
              resolve(null);
            }
          }
        }, 80); // short delay for render
      });
    }

    // V·∫Ω ch·ªØ l√™n canvas QR (tr·∫£ v·ªÅ dataURL ·∫£nh cu·ªëi c√πng)
    function drawTextToCanvas(qrCanvas, item) {
      const padding = 12;
      const qrW = qrCanvas.width;
      const qrH = qrCanvas.height;
      const textAreaHeight = 110; // ch·ªó cho c√°c d√≤ng text
      const canvas = document.createElement('canvas');
      canvas.width = qrW + padding * 2;
      canvas.height = qrH + padding + textAreaHeight;
      const ctx = canvas.getContext('2d');

      // background tr·∫Øng
      ctx.fillStyle = '#fff';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // v·∫Ω QR (gi·ªØa theo chi·ªÅu ngang)
      const x = (canvas.width - qrW) / 2;
      ctx.drawImage(qrCanvas, x, padding, qrW, qrH);

      // v·∫Ω vi·ªÅn nh·ªè quanh QR (t√πy ch·ªçn)
      ctx.strokeStyle = '#e0e0e0';
      ctx.lineWidth = 1;
      ctx.strokeRect(x - 1, padding - 1, qrW + 2, qrH + 2);

      // v·∫Ω text
      ctx.fillStyle = '#000';
      ctx.textBaseline = 'top';
      const left = 12;
      let y = padding + qrH + 8;

      // S·ª≠ d·ª•ng font ph√π h·ª£p; tu·ª≥ ch·ªânh k√≠ch th∆∞·ªõc n·∫øu c·∫ßn
      ctx.font = 'bold 14px Arial';
      ctx.fillText('S·ªë t√†i kho·∫£n: ' + (item.AccountNumber || ''), left, y);
      y += 20;

      ctx.font = '14px Arial';
      ctx.fillText('T√™n t√†i kho·∫£n: ' + (item.AccountName || ''), left, y);
      y += 20;

      ctx.fillText('S·ªë ti·ªÅn: ' + (item.Amount || ''), left, y);
      y += 20;

      // N·ªôi dung c√≥ th·ªÉ d√†i -> wrap text
      const note = 'N·ªôi dung: ' + (item.Remark || '');
      ctx.font = '14px Arial';
      wrapText(ctx, note, left, y, canvas.width - left*2, 18);

      return canvas.toDataURL('image/png');
    }

    // H√†m wrap text ƒë∆°n gi·∫£n
    function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
      const words = text.split(' ');
      let line = '';
      for (let n = 0; n < words.length; n++) {
        const testLine = line + words[n] + ' ';
        const metrics = ctx.measureText(testLine);
        const testWidth = metrics.width;
        if (testWidth > maxWidth && n > 0) {
          ctx.fillText(line, x, y);
          line = words[n] + ' ';
          y += lineHeight;
        } else {
          line = testLine;
        }
      }
      ctx.fillText(line, x, y);
    }

    // T·∫£i t·∫•t c·∫£ (zip)
    async function downloadAll() {
      if (!qrList || qrList.length === 0) {
        alert('Ch∆∞a c√≥ ·∫£nh QR ƒë·ªÉ t·∫£i.');
        return;
      }
      const zip = new JSZip();
      for (const item of qrList) {
        try {
          const blob = dataURLToBlob(item.dataUrl);
          zip.file(item.filename, blob);
        } catch (err) {
          console.error('ZIP l·ªói cho', item.filename, err);
        }
      }
      const content = await zip.generateAsync({type:'blob'});
      saveAs(content, 'all_qr_codes.zip');
    }

    // Helpers
    function dataURLToBlob(dataurl) {
      const arr = dataurl.split(','), mime = arr[0].match(/:(.*?);/)[1],
            bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n);
      while (n--) u8arr[n] = bstr.charCodeAt(n);
      return new Blob([u8arr], {type:mime});
    }

    // X√≥a k√Ω t·ª± html (ƒë·ªÉ an to√†n hi·ªÉn th·ªã)
    function escapeHtml(text) {
      if (!text) return '';
      return String(text).replace(/[&<>"']/g, function (m) {
        return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'})[m];
      });
    }

    // Tho·∫£ thu·∫≠n: m·ªói l·∫ßn render l·∫°i filter s·∫Ω t·∫°o ·∫£nh m·ªõi n·∫øu ch∆∞a cache; item.dataUrl ƒë∆∞·ª£c cache tr√™n object item.
  </script>
</body>
</html>
